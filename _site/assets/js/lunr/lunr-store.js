var store = [{
        "title": "[포스팅 예시] 이곳에 제목을 입력하세요",
        "excerpt":"🦥 본문   본문은 여기에 …  ","categories": ["Categories1"],
        "tags": ["tag1","tag2"],
        "url": "/categories1/post-name-here/",
        "teaser": null
      },{
        "title": "[포스팅 예시] 이곳에 제목을 입력하세요",
        "excerpt":"🦥 본문   본문은 여기에 …  ","categories": ["Categories2"],
        "tags": ["tag1","tag2"],
        "url": "/categories2/post-name-here-2/",
        "teaser": null
      },{
        "title": "[포스팅 예시] 이곳에 제목을 입력하세요",
        "excerpt":"🦥 본문   본문은 여기에 …  ","categories": ["Categories3"],
        "tags": ["tag1","tag2"],
        "url": "/categories3/post-name-here-3/",
        "teaser": null
      },{
        "title": "[포스팅 예시] 이곳에 제목을 입력하세요",
        "excerpt":"🦥 본문   본문은 여기에 …  ","categories": ["Categories4"],
        "tags": ["tag1","tag2"],
        "url": "/categories4/post-name-here-4/",
        "teaser": null
      },{
        "title": "[포스팅 예시] 이곳에 제목을 입력하세요",
        "excerpt":"🦥 본문   본문은 여기에 …  ","categories": ["Categories5"],
        "tags": ["tag1","tag2"],
        "url": "/categories5/post-name-here-5/",
        "teaser": null
      },{
        "title": "[포스팅 예시] 이곳에 제목을 입력하세요",
        "excerpt":"🦥 본문   본문은 여기에 …  ","categories": ["Categories6"],
        "tags": ["tag1","tag2"],
        "url": "/categories6/post-name-here-6/",
        "teaser": null
      },{
        "title": "[포스팅 예시] 이곳에 제목을 입력하세요",
        "excerpt":"🦥 본문   본문은 여기에 …  ","categories": ["Categories7"],
        "tags": ["tag1","tag2"],
        "url": "/categories7/post-name-here-7/",
        "teaser": null
      },{
        "title": "[OS] Ch1. Introduction",
        "excerpt":"   노션으로 작성된 글을 백업 용으로 옮긴 것입니다. 개인적으로 공부하며 작성된 글이기에 틀린 정보가 있을 수 있습니다    Operating System  - Computer System Sturcture의 component             HW : 기본 computing resource 제공   ex) CPU, Memory, I/O Device   Operating Systme : 여러 application과 user 간의 HW 사용을 제어하고 조정   Application Program : System resource 가 user computin probelm 을 해결하는데 사용되는 방식 정의    ex) word processes, web browser   User   ex) people, machines, other computer   - OS 란?      computer의 user와 computer 의 HW 간 intermediary (중개자) 역할을 함            HW control &amp; manage       basic application 제공           Goal of OS → 결국 성능을 어떻게 더 좋게 할 것인가 . .            user program 실행하고, user problem 을 쉽게 해결할 수 있도록 제어 서비스 향상       computer system 을 사용하기 쉽게 user 에게 편리한 환경 제공하지       computer HW 를 효율적으로 사용하게 system 성능 향상           - Definition of OS? OS 역할!      OS는 Resource allocator            모든 리소스 관리하고 할당하는 역할       효과적이고 공평한 리소스 사용을 위해 상충되는 요청들 (여러 application 이 동일 resouce 에 접근하는 경우) 사이에서 결정내려줌           OS 는 Program controler            application과 I/O device를 제어감       program 실행을 제어해서 computer 사용의 error 와 improper 방지              사실 보편적인 정의는 없음 . . → OS 명령 시 오는 모든 것 정도로 생각하면 ㅇㅇ   Kernel : computer 에서 항상 실행 중인 한 program 으로 OS 의 core part 임 → 그 외는 system program (OS 와 함께 제공) 이거나 application program 임   system program (system utllities)            OS 와 associated 이지만 kernel 의 일부는 아님       program 개발과 실행하는데 편한 환경 제공    ex) editer, compiler, debugger, shell …               Computer System Architecture   - Single Processor System      single general-purpose processor 사용   special-purpose processor 사용하는 경우도 있긴 함!            graphics controller 나 disk controller       여기선 user process 실행하지 않음           - Multi-Processor Systme      paraller system 이나 tightly-coupled system 이라고도 알려져 있음   장점            throughtput 증가       multi single processor system 보다 경제적임       신뢰성 증가 → 서로의 영역에 접근을 안해서, , ?           Type            Asymmetric Multiprocessor (AMP) : 각 process에는 특정 task 가 할당되어 그 task 만 수행함! 그리고 master / slave procesor 로 나뉘어 master 가 slave 들 scheduling 하거나 관리       Sysmmetric Multiprocessor (SMP) : 모든 process 는 동일하며 모든 task 수행 가능! → 일반적으로는 보통 이 type                   -&gt; CPU 간은 BUS 나 Switch 로 연결되어 있고, 각 CPU 는 identical                   - Multi-core Processor System      single chip 에 multi computing core 가 존재 → CPU 의 한 Chip 에 여러 core 가 존재   N-core 가 있는 multi-core processor 는 N standard processor 로 OS 가 인식함   Type            Uniform Memory Access (UMA) : 모든 core 는 모든 memory 모듈에 대해 동일한 access time 을 가짐       Non-uniform Memory Access (NUMA) : core 마다 각 memory 모듈의 access time 이 다를 수 있음                       UMA 는 물리적 거리가 같기에 접근 시간이 동일한데       NUMA 는 물리적 거리가 다르기에 접근 시간이 다름           - 용어 정리?      Processor : logical 실행 단위 or 물리적 chip을 설명하기 위해 사용 → CPU 자체를 의미하기도 함! 근데 multi-core 에서는 좀 애매해짐   Core : L1 cache 및 funtional unit 을 포함하는 logical 실행 단위 → Processor 에 포함된 작업 단위   Chip : computer 에 있는 물리적 intergrated circuit (IC)   Soket : computer matherboard (메인모드) 에 있는 물리적인 connector 로 signle phtsical ship 을 수용 → soket 여러개인 메인보드는 multi-core chip 을 수용할 수 있음   - Operating System Structure      효율성을 위해 Multiprogramming이 필요함!            why?     → single programe은 CPU 및 I/O 장치를 항상 사용할 수 없는데 (독점 못하니까 ㅜㅜ) user는 여러 program을 실행해야함       Multiporgramming은 작업(code &amp; data)를 organize하여 CPU가 항상 하나만 실행 할 수 있도록 해줌     → 여러 process 들이 CPU 사용할 수 있게       system의 전체 작업 중 일부는 memory에 보관됨       Job Scheduling을 통해 실행할 하나의 작업이 선택됨       대기해야 할 때 (I/O Burst) OS는 다른 작업으로 전환됨           Timesharing (Multitasking)은 CPU가 작업을 너무 자주 전환해서 사용자 작업이 실행되는 동안 해당 작업과 상호작용 할 수 있는 interactive Computing (대화형 컴퓨팅)을 만들어내는 logical extension            respones time (요청 보내고 응답 받는데 걸리는 시간) 이 1초보다 짧아야함       각 사용자는 momory에서 실행되는 적어도 하나의 프로그램을 가지고 있음 → process       여러 작업이 동시에 실행될 준비가 된 경우 → CPU Scheduling을 통해 나눠주는       만약 process가 memory에 맞지 않으면 swapping을 통해 momory 밖으로 옮겨 실행할 수 있도록 함       가상 momory는 완전히 memory 에 있지 않은 process의 실행을 허용함 → Ch9 에서 좀 더 자세히           +) 사실 명확하게는 multitasking이랑은 다름 ! Timesharing 은 CPU 시간을 작은 단위로 분할하여 여러 사용자가 동시에 접근 할 수 있게하는 것           Computer System Operation   - Computer System Operation      I/O device 와 CPU는 동시에 실행될 수 있음 → 그래서 I/O burst 와 CPU Burst 가 따로인겨 !   각 device controller는 특정 device type을 담당하고 local buffer를 가지고 있음   CPU는 Main Memory ↔ local buffe 양 방향으로 data를 이동시킴   Device controller는 Interrupt를 발생시켜 CPU에게 operation이 끝났다는 것을 알림   - Computer System Operation들           Interrupt : 중요 event를 알리기 위해 processor에게 전달되는 signal       ex) 마우스 클릭 이벤드              HW와 SW는 interrupt를 유발할 수 있음                intterupt는 interrupt vector를 통해 보통 interrupt service routine으로 control을 전달하며, 이 interrupt vector에는 모든 service rouine의 address가 포함되어 있음           → 어디부터 실행하면 되는지 알려줘서 control 전달                   +) interrupt service routine : Computer System에서 발생하는 interrupt를 처리하기 위해 미리 정의된 code block → 즉 발생했을 때 어떻게 처리할 것인지       HW-generated interrupt 는 OS   SW-generated interrupt 에는 Trap과 Exception가 있음                     Trap : OS service를 위한 software request → 개발자가 의도를 가지고 design한           ex) file open.. 과 같은 system call                        Exception : software error → trap과 달리 bug..           ex) division by zero                   [Interrupt 과정]      현재 실행 중인 instruction 완료 (중단)   user program의 state를 reg나 stack에 저장   고정된 위치 (서비스 루틴의 address) 곳으로 실행 이동   interrupt service routine 실행   저장된 user program의 state로 restore   1에서 중단된 user program 실행 재개      OS와 user는 computer system의 HW/SW resource를 공유함 → 여기서 OS의 user 신뢰 문제 발생…            user program이 다른 program 이나 system 을 kill 해서는 안됨       그래서 Dual-mode를 사용함 !!           - Dual-mode      OS가 자신과 다른 sysptem component들을 보호하도록 하기 위해 사용하는   User mode / kernel mode 로 나뉨   User mode : 제한된 operation만 수행 가능 → application은 기본이 이 mode   Kernel mode (supervisor, system, privileged) : 모든 operation 수행 가능 → kernel은 이 mode   Mode bit (HW 에서 제공)            system이 User(mode bit = 1) / Kernel code(mode bit = 0) 중 뭐를 실행하고 있는지 구별 할 수 있도록       특권으로 설정된 어떤 instruction (다른 user나 system에게 영향을 줄 수 있는)은 kenel에서만 실행 가능함 (only kernel mode)       system call은 mode를 kernel mode로 변경하고 실행한 다음 return 되면 user mode로 다시 변경함 → kenel 에서 실행되는 동작이라서                 system call이 될 경우 trap을 발생시키고, mode bit를 0으로 바꿈   그리고 system call 처리후에 bit를 다시 1로 돌린 다음에  return       Management   - Timer      무한 루프나 process가 과하게 resource를 차지하는 것을 막기 위한 방법 → OS 는 효율적이게 동작하기 위해 관리하는 manager니까   특정 주기 이후에 interrupt 설정되게끔 → 주기마다 작업이 실행            OS는 counter를 설정하고 매 clock tick 마다 counter를 감소 시킴       counter 가 0이 되면 interrupt 설정                control을 되찾거나 할당된 시간을 초과한 program을 종료시키기 위하여 process scheduling 전에 설정       → scheduling 전에 timer 확인! 그래야 지난 애 있으면 대기나 다른 상태로 바꿔야 schduling 때 처리되니까       - GHz      CPU 에서 GHz는 clock frequency이며, clock rate, clock speed라고 하기도 함   일반적으로 clock speed가 빠를수록 CPU가 빠름        clock speed는 CPU 가 초당 실행하는 cycle 수로 측정하며 그 단위가 GHz       ex) A CPU with a clock speed of 3.2 GHz executes 3.2 billion cycles per second.       - Process Management      process는 실행 중인 program이며, system내 작업 단위임   Program은 Passive(패시브 ㅇㅇ) entity이고, Process는 Active(실행 중인) entity → 즉 program 중 실행 중인 것이 process   Process는 작업을 수행하기 위해 resources 가 필요함            CPU, Memory, I/O, File       Initializaion data → Input 받거나 . .           process 종료시 재사용 가능한 resources 를 되돌려 받아야함 → 다시 반납하쇼   Single-threaded process는 하나의 program counter (PC)를 가지고 있다            program counter (PC) : 실행할 다음 instruction 의 위치 지정       process는 완료 될 때 까지 한번에 하나씩 순차적으로 inst을 실행함           Multi-thredaded process는 thread당 하나의 program counter를 가지고 있다   일반적으로 system은 하나 또는 그 이상의 CPU들에서 동시에 실행 중인 많은 process들(some user, some OS)을 가지고 있다.            process / thred 간 CPU multiplexing를 통한 concurrency (동시성)           Process Management Activities            CPU에서 process 및 thread scheduling       user &amp; system processes 생성 및 삭제       process 일시 정지 및 재개       process synchronization 를 위한 매커니즘 제공                    process synchronization : 여러 process가 공유 중인 resouce에 접근하려고 할 때 실행 순서를 제어하여 서로의 작업에 영향을 주지 않도록 하는 기술                       process communication 을 위한 매커니즘 제공                    process communication : 서로 다른 process 간 data나 masseage를 주고 받는 기술                           - Memory Management      processing 전 후의 모든 Data은 main memory 에 있음!   실행을 위해 memory 에 있는 모든 instruction   Momory management는 memory 에 저장될 내용과, 그 시기를 결정함            user를 위해 CPU utilization 와 computer response 최적화           Main Memory Management Acticities            현재 실행 중인 memory part와 누구에 의해 사용 중인지 추적       memory 안팎으로 이동할 process (또는 그 일부) 및 data 결정       필요에 따라 memory 공간 할당 및 할당 해제           보조 기억장치도 관리해요 !   - Storage Management      OS는 information storage 에 대해 균일하고 논리적인 view를 제공            물리적 속성을 논리적 storage 단위인 file로 abstract → file 의 기본 컨셉       각 media 은 device (disk srive, tape drive)에 의해 control 됨                    access speed, capacity, data-transfer rate, access method (sequential or random) 이 속성에 포함되어 있음                           File-System Management            일반적으로 file은 directory들로 organiz됨       누가, 무엇에 access할 수 있는지 셜정하기 위해 대부분의 system에 대한 acces control       OS Activities                    file &amp; directory 생성 및 삭제           file &amp; directory 조작을 위한 primiotives           보조 storage에 file mapping           안정적인 (non-volatile) storage media에 file backup                   +) 어떻게 power 없이 안정적으로 file을 storage할 것인지가 OS에서는 중요한 도전과제                  ","categories": ["[2023]Operating System"],
        "tags": ["OS","강의필기"],
        "url": "/categories/study/2023_OS/ch1",
        "teaser": null
      },{
        "title": "[OS] Ch2. Operating-System Structure",
        "excerpt":"   노션으로 작성된 글을 백업 용으로 옮긴 것입니다. 개인적으로 공부하며 작성된 글이기에 틀린 정보가 있을 수 있습니다    OS Services              OS Services    - Operating System Service      OS 별로 차이가 있긴 하나 보통 다음 4가지의 service로 구성            Booting Service : Couputer HW를 관리하고 Program을 실행 할 수 있도록 부팅함       User Service : 프로그래머가 programming 작업을 쉽게 할 수 있도록 함       System Service : System 이 효율적으로 동작하도록 보장       System Call : Program과 OS 간의 interface 를 제공하여 System 기능을 사용 할 수 있도록           -  User Service           User Interface :  대부분의 OS는 user unterface (UI)를 가지고 있음       ex) Comman-Line(CLI), Graphics User Interface(GUI) 등..            Program Execution : system은 program을 memory에 로드, 해당 program을 실행하고 정상 또는 비정싱 시 실행을 종료 할 수 있어야 함       ex) 메모리 할당, 해제, 프로세서 스케줄링       I/O Operation : 실행 중인 program에는 I/O가 필요할 수 있음! OS 는 I/O 동작 방법을 제공   File-System Manipulation : program은  file과 directory를 읽고 쓰고, 생성하고, 삭제하고, 검색하고 나열하고 권한을 관리해야함   Communications(통신) : proces는 같은 computer 내  process들이나, 네트워크로 연결된 다른 computer의  process들과 information을 교환할 수 있음            공유 memory 나 message 전달을 통해 통신이 이루어질 수 있음           Error Detection : OS 는  가능한 모든 HW/SW 수준에서의  error을 탐지하고 system을 모니터링하여 조정함으로 HW 문제를 예방해야함            user program, CPU, memory hardware, I/O device 등에서의 error 탐지       각 error에 대해 OS는 적절한 조치를  취해야함!       Debugging facilites가 도움이 될 수 있음           - System Service      Resource Allocation : 다수의 user나 job이 동시에 실행 될 경우 각각에 res를 할당해주어야함            다른 scheduling 방식을 가진 여러 종류의 resource 존재           Accounmtin / Logging : 어떤 user가 어떤 종류의 resource를 얼마나 많이 사용하고 있는지 정보를 저장하고 추천            user service를 개선하고 system을 재구성하는 연구, 통계 자료로도 사용           Protection and Security : computer system에 저장된 정보의 소유자의 사용을 제한할 수 있음. 그리고 서로 관련이 없는 여러 perocess이 동시에 실행 될 때는 다른 process나 OS를 방해하지 못하도록 보호해야함            Protection : resource에 대한 모든 액세스를 제어       Security : 외부 I/O를 방어하고 외부 user에 대해 인증을 요구               System Calls   - System Calls      OS에서 제공하는 service에 대한 programming interface → 실행 중인 prgram과 OS 간의 interface   일반적으로 high-level language인 C/C++ 로 작성됨   직접적인  system call 사용이라 아니라 주로 high-level  Application Program Interface (API)을 통해 system call 에 엑세스            potrability (이식)이 편함 system call은 더 자세하고 작업하기 어렵기 때문에!           일반적인 3가지 API            Window를 위한 Windows API       POSIX-based system(모든 버전의 UNIX, Linux, Mac OS X 포함)을 위한 POSIX API                    휴대용 OS Interface (POSIX) : OS 간의 호환성을 위해 IEEE가 정한 표준 제품군                       Java Virtual Machine (JVM)을 위한 JAVA API                ex)                 한 file의 내용을 다른 file로 복사하는 system call                           standard api         - System Call Implementation      System call interface는 API에서 function call을 가로채 OS Kernel에서 의도한 system call을 호출하고, system call의 state, 및 returen value를 반환함   일반적으로 각 system call에는 번호가 할당됨            system call interface는 이러한 번호에 따라 indexing된 table 을 유지, 관리함           caller는 system call이 어떻게 구현되어있는지 알 필요가 없음.            그냥 API를 따르고 호출 결과로 OS 가 수행할 작업만 이해하면 됨 → 걍 쓸거니까,,       API에 의해 OS Interface의 자세한 부분은 programer에게 숨겨짐              API - System Call - OS 관계도           User Application이 open()이라는 system call을 호출한 경우            Application이 open()이라는 system call 호출       system call interface는 open()의 system call number를 확인하고, 이를 실행하기 위해 kernel mode로 변경       kernel mode 에서 open()에 필요한 parameter들을 검사       file system 에서 file의 meta data를 읽어와 File Descriptor에게 할당하고, file table에 등록       File Descriptor는  open() 의 반환 값으로 user application에게 반환됨       반환된 File Descriptor를 이용하여 user application은 file을 읽거나 쓸 수 있음           - Standard C Library Example          Standard C Library 는 Linux와 UNIX 에게 일부 system call interface를 제공함   C program에서 printf()를 호출하면, system call인 write()를 호출함       OS Design and Implementation (OSDI)   - OS Design and Implementation      OS 의 Design과 Implementaion은 해결하지 못 하는 문제이지만, 일부 approache들은 성공적으로 증명되었다 → 나중에 나와요   다양한 OS 내부 구조들은 크게 달라질 수 있음   Goal과 Specification을 먼저 정의해서 OS 설계를 시작해야함!   System design은 HW 선택과 system type에 의해 영향을 받음            Batch, time shared, single user, multiuser, …           User goals &amp; System goal            User goal : OS는 사용하기 편하고, 배우기 쉬우며, 신뢰성이 있고, 안정하고 빠르게 동작해야함       System goal : OS 는 설계, 구현, 유지 보수가 용이해야하고, 유연하,며 신뢰성이 있으며, 오류가 없고, 효율적이어야함           OS의 requirement를 정의가 (정의하는 솔루션이) 유일한 것은 아님!!            다양하기에 OS 가 다양한 것           -  Seperate Mechanism &amp; Policy      Mechanism와 Policy를 분리하는 것이 OS 설계 및 구현에서의 중요한 principle            Mechanism : 어떻게 할 건가?       Policy : 무엇을 할 건가?           ex) CPU 보호를 보장해야함!!       →  Mechanism : Timer 구조를 사용하자, Policy :  특정 user에 대해서 timer를 얼마나 길게 설정하지?            Mechanism와 Policy를 분리는 policy 결정이 나중에 변경되는 경우에 대처할 수 있는 유연성을 제공함       ex) CPU-intensive 한 program보다 I/O-intensive한 program에 우선순위를 부여하는 policy           OS Structure   - Simple Structure (Monolithic, 단일구조)      OS 기능을 kernel 과 동일한 memory 공간에 두고 system call 만으로 사용함   Not Well-definde인 구조   작고 단순하며 제한된 system으로 시작하여 성장!   module로 나누지 않음   [MS-DOS]         초기에는 memory 공간이 제한적이었기에, 최대한 적은 공간을 차지하면서 최대한 많은 기능을 제공하기 위해 초기에 작성됨   처음에는 간단한 OS 였지만, 시간에 따라 컴퓨터 기술이 발전하면서 새로운 기능이 계속해서 추가됨 → 초기에 계획된 제한적 범위를 넘어섬   초기에는 I/O Interface와 level이 분리되어 있지 않아 application이 직접 I/O Device에 접근할 수 있음            오작동과 악성 프로그램의 위험성이 높았음 ㅠㅠ           그 당시 HW 도 제한적이었기에 Dual Mode를 지원하지 않았음            그렇기에 이러한 HW에서도 잘 동작되도록 개발           [Traditional UNIX (Monolithic)]         매우 광범위한 기능이 Kernel에 집약되어있음                     Kernel 아래 System call interface 이하의 모든 기능이 kernel에 통합됨 (단일층 . .)           → kenel은 OS 에서 거의 모든 일을 처리함                   매우 적은 Layering (계층구조)을 가지고 있으며, 두꺼운 monolthic layer로 구성되어 있다.            적은 만큼 각 계층간 interface가 충분하지 않기에, 구현과 유지보수가 어려움           즉. Tranditional UNIX는 기능이 통합된 kernel과 layering이 얇은 구조로 인해 확장성이 제한적이며, 구현과 유지 보수가 어려움   [Monolithic Structure]                 OS는 system Call Interface 아래 하나의 장소에 모두 포함   Application은 system call interface를 사용하여 kernel과 상호작용   ex) Unix, Window XP, Linux과 같은 상용 system에서 일반적으로 사용   장점            성능 우수 → 직접 통신이라       kernel 개발자가 쉽게 개발 할 수 있음           단점            kernel component 간 보호 없음 → 다 통합된 공간에 있으니..       쉽게 확장되지 않음 → 다 kernel 에 넣어야해서       전체 구조가 복잡해짐       하나에 문제가 발생하는 순간 어디에 문제가 발생한 것인지 몰라 복구 어려움           - Layerd Approach                  OS 는 하위 layer위에 구축된 여러 layer (level)로 나뉨            The bottom layer (level 0) : HW       The highest Layer (level N) : User Interface           Moularity를 통해 각 layer는 하위 level layer의 functions(operations) 및 service만을 사용하도록 선택            자신보다 하위인 layer에서 제공하는 functions(operations) 및 service를 이용해 본인 layer를 구축함           장점            각 layer가 서로 분리되어있기에 보안이 강화       각 layer의 문제가 전체 system에 영향을 미치는 것을 방지할 수 있고 독립적으로 디버깅 및 교체 가능                    low-level routines의 구현 세부사항을 숨김                       유연하고 확장성이 높은 OS를 만드는데 유용함           단점            여러 layer를 적절하게 정의하는 것에 어려움이 있을 수 있음       효율성 → layer가 많을 수록 function간 더 많은 Indirection (간접 참조)가 필요하고 이로 인해 function overhead가 커짐           - Microkernels System Structure      Microkernel은 필수적인 OS 기능만을 포함시킨 축소된 OS core   기존 OS에서 kernel에 있던 기능을 user space로 옮겨, kernel에는 기본적인 기능만 남겨둠 → 필수만 남긴다!   Kernel에 남긴 기능            기본적인 Memory 관리       I/O와 iterrup 관리       Process간 통신       기본 Scheduling           전통 OS에 포함되는 많은 service들이 User Process로 동작            Device driver       File system       Virual Memory 관리       Security sercvice       etc..           example: QNIX, Tru64, UNIS, Mach        User modules간 통신은 message passing을 통해 이루어짐       ex) 디스플레이를 필요로 하는 클라이언트 프로그램은 마이크로커널과 메시지 교환을 통해 간접적으로 디스플레이 서비스와 통신                   장점            확장성 : 새로운 서비스를 Kernel이 아닌 user space에 추가하므로, microkenel 기반 OS를 확장하는 것이 더 쉬움       호환성 : Microkernel만 변경하고 그 외의 service는 변경하지 않아도 되기에 다른 CPU로 port하는 것이 쉬움.       신뢰성 &amp; 보안성 : 많은 코드가 kenel mode에서 실행되지 않기에 User space service의 error가 kernel space에 영향을 주지 않아 안전함           단점            Performance overhead : User space와 kernel space 사이에 통신이 많기에 이에 따라 overhead가 발생 할 수 있음       Communication from User space to Kernel space : 사용자 공간의 서비스가 커널 공간과 통신할 때 보안 문제가 발생 가능성                Layer VS Mocrokernel                   - Modules      많은 최신 OS는 kernel module을 구현함   Object-oriented approach와 유사함            각 core component는 분리되어 있음       각 component은 알려진 interface를 통해 다른 component와 통신함       필요한 경우 kernel 내에서 load 가능함           전반적으로 layer 구조와 비슷하지만 더 flexibility함            어떤 module도 다른 module을 호출 가능함!           Modules은 microkernel 방식과도 유사하지만, Modules은 kernel 내부에 있으며 통신을 위한 message passing이 필요하지 않음   [ex. Solaris Modular Approach]          Core Kernel 을 중심으로 7가지 type의 module로 구성한 소프트웨어 모듈화 접급 방식            scheduling classes       file systems       loadable system calls       executable formats       STREAMS modules       miscellaneous       device and bus drivers          ","categories": ["[2023]Operating System"],
        "tags": ["OS","강의필기"],
        "url": "/categories/study/2023_OS/ch2",
        "teaser": null
      },{
        "title": "[OS] Ch3. Processes",
        "excerpt":"   노션으로 작성된 글을 백업 용으로 옮긴 것입니다. 개인적으로 공부하며 작성된 글이기에 틀린 정보가 있을 수 있습니다    Process Concept   - Process Concept                    Process : 실행 중인 progeam → 실행되었으니 memory 에 적제되었고, 자신만의 memory 영역이 있는 것 !   Process 실행은 무조건 순차적으로 실행되어야 함   Process에 포함 된 것            Text Section (loaded Progeam)       Program Counter       Stack (Temporay data) : 함수 parameter나, reture address, local variable을 저장하는 일시적인 memory 영역       Head : 동적으로 할당된 memory → Stack 이랑 비슷하지만 동적으로 할당된다는 점이 다름! 더 static하고 global함       Data Section (Global Variables) : Global variable등 초기화된 data를 저장           - Process State      Process가 실행되는 동안 process의 state는 계속해서 변경됨            new : Process가 생성되는 중       running :  Instriction이 실행되고 있는 상태       waiting : Process가 어떤 event가 발생하기를 기다리는 중       ready : Process가 processor에 할당되기를 기다리는 중       terminated : process가 실행을 완료함               - Process Lift Cycle          New → Ready : 새로 생성되는 New에서 실행 가능한 상태인 Ready 로 전환   Ready → Running : Kernel이 scheduling 할 때 process는 ready 상태에서 running으로 전환   Running → Waiting : 만약, Process가 blocked되어 event가 발생하기를 기다린다면 waiting으로 전환 ex) I/O   Waiting → Ready : Event가 완료되면 다시 Ready 상대로 전환   Running → Ready : Interrupt가 발생하면 실행 되다가 다시 실행 가능 상태인 ready로 전환   Running → Terminated : exit()가 호출되면 실행 완료한 것이므로 종료하기 위해 terminated로 전환   - Process Control Block (PCB)         Particular process를 관리하기 위해 필요한 정보가 포함된 OS의 데이터 구조   각 Process와 관련된 정보들 → OS에서 process를 표현하는 .. !            Process State       Program Counter       CPU registers       CPU Scheduling information       Memory-management information       Accountin information       I/O status information           Process Scheduling   - Context Switch          P1가 CPU 사용중인 상황인데, P2가 CPU를 사용해야하는 일이 발생   Kernel의 Interttupt Handler가 P1을 중지하고 PCB0에 P1에 대한 정보(reg 정보, process state 등)를 저장함   다음에 실행할 P2에 대한 정보를 PCB1에서 가져옴   Interrupt Handler는 다시 CPU를 P2에 할당하고, P2에서 PCB1에서 받아온 reg 정보, process state를 읽어와 CPU가 실행하도록 함   P2 실행            CPU Switch from Process to Procee       CPU가 다른 process로 전환된다면 system은 무조건 이전 process의 state를 save하고, 새로운 process의 state를 load 해야함       Process의 Context는 PCB로 표현됨       Context Switch 과정은 사실 유용한 작업을 수행하는 것은 아니고 단지 전환이기에 순전한 overhead 임 ㅜㅜ       switch되는 속도는 memory 속도나, 복사해야하는 reg 수 등등에 따라 달라짐                 보통은 마이크로 초 단위           - Process Scheduling Queues           Job Queue : System의 모든 실행 가능한 process들의 set   Ready Queue : Main memory에 상주하며, 실행될 준비가 되었거나(ready) 기다리는 (waiting) 상태의 process들의 set   Device Queue (I/O wait Queue) : I/O Device를 기다리는 procee들의 set            process는 다양한 Queue들 사이에서 이동함       Queue는 보통 linked list로 구현       Process schduling하는 과정 Queueing-Diagram으로 표현                            Process는 I/O request를 발생 시킨 후 I/O Wait Queue에 추가될 수 있음       process는 새로운 child process를 생성한 다음, child의 종료를 기다리는 동안 ready Queue에 추가될 수 있음       Process가 interrupt 또는 time slice expired에 의해 강제로 core 에서 제거 되었다면 Ready Queue에 추가될 수 있음           - Schedulers      Long-term Scheduler (Job Scheduler) : Ready Queue로 추가할 process 선택하는 것이 목적            매우 드물게 호출 : (second, miniutes) → 느려도 괜찮앙       Degree of multiprogramming를 제어           Short-term Scheduler (CPU Scheduler) : 다음에 실행되고 CPU에 할당할 process 선택하는 것이 목적            매우 자주 호출 : (milliseceons) → 빨라야함!!           Process는 둘 중 하나로 설명 가능            CPU-bound-process : 계산에 더 많은 시간을 소비하고, 적고 긴 CPU Burssts → Long-term                    그래서 Long-term Scheduler는 결정을 신중해야해야함..                       I/O-bound-process : 계산보다 I/O 를 수행하는데 더 많은 시간을 소비하고. 많고 짧은 CPU Bursts →Short-term       CPU Bursts : Process가 CPU를 사용하는 시간               +) Medium-term Scheduler :   Time-sharing system 에서 Degree of multiprogramming (동시에 실행 중인 program 수?)를 줄이기 위해 process를 memory에서 temporarily(일시적)으로 제거함  → 나중에 process 재시작함!!   → Swapping       Operation on Processes   - Process Creation (프로세스 생성)          Creating precess를 Parent Process라고 하고 이때 생성되는 새 process를 Child Process라고 함 → Parent가 Child Process 생성   생성된 Child Process가 또 다른 Process를 생성하면서 Process tree를 만듦   일반적으로 Process는 식별자(PID) 를 통해 식별되고 관리됨   Resource Sharing            부모와 자식은 모든 리소스를 공유 → 둘 다 동일한 리소스에 접근 가능       자식은 부모의 일부 리소스를 공유 → 자식은 부모의 일부 리소스에만 접근할 수 있음       부모와 자식은 리소스를 공유하지 않음 →  서로 독립적           Execution            부모와 자식이 동시에 실행       부모는 자식이 terminate될 떄 까지 wait           Address Space            자식은 부모의 duplicate       자식은 새로운 program을 load           - Process Creation in UNIX      UNIX에서 process를 생성하는 system call들           fork() : 새로운 process를 생성함! → 부모 process의 모든 것을 그대로 복제시켜 자식 process 생성   exec() : Process의 memory space를 fork로 생성된 새 process로 대체하기 위해 fork 다음으로 실행되는 system call            fork할 때 부모를 그대로 복제하면서 메모리 공간도 그대로 복제시켜버림..       복제된 process가 같은 program이 아니라 다른 program을 실행시켜야 하므로 새 memory space로 덮어씌움           → 즉 그대로 복제 한 다음에 실행할 program 으로 덮어씌우는 형태로 보통 fork-exec  같이 사용함       wait() : 부모에 의해 호출됨! 자식 process가 종료 될 떄 까지 부모 process를 일시적으로 중단하고 대기시킴   exit() : 호출한 prcoess를 종료   - Process Termination      process는 마지막 statement를 실행하고 OS에게 삭제를 요청하여 종료함 (exit)            Process는 부모에게 state value를 return할 수도 있음 → wait를 통해!       Process의 리소스는 OS에 의해 해제됨           부모는 자식 process의 실행을 종료 시킬 수도 있음 (abort)            자식이 할당된 리소스를 초과하는 경우       자식에게 할당된 작업이 더 이상 필요하지 않은 경우       부모가 종료된 경우                    일부 OS는 부모가 종료되면 자식의 계속 실행을 허용하지 않는 것도 있음 → 그럼 이제 모든 자식이 연쇄적으로 다 종료되는..                           Interprocess Communication   - Cooperating Processes (협력 프로세스)      Cooperating Process는 독립적인 proces와 달리 다른 process의 실행에 영향을 줄 수도, 받을 수도 있음!!            +) 독립적인 Process는 다른 process의 실행에 영향을 줄 수도, 받을 수도 없음       서로 상호작용하면서 특정 기능을 수행           장점 (Process Cooperation 환경을 제공하는 이유)            정보 공유 : 같은 데이터에 여러 user가 관심을 가질 수 있음 (ex. shared files) 그러면 제한된 리소스 사용 효율성 증가       연산 속도 향상 : task를 subtask로 나눠서 병렬로 실행할 수 있음       모듈성 : 모듈 방식으로 system을 디자인하면서 system function을 separeate process로 나눌 수 있음       편리성 : 동시에 개별 사용자가 많은 task를 를 수행 할 수도 있게 됨           단점            병행 process간의 synchronization 되어야한다는 문제와 이때의 reace condition           - Interprocess Communication (IPC)      Process간 통신하고 synchronize하는 매커니즘!        IPC에는 2가지 모델(방법)이 있고 둘다 OS에서 일반적으로 사용             왼) Message Passing         오) Shard Memory                        Shard Memory : 동일한 주소 공간과 공유 변수 사용 → 즉 공유되는 memory 공간이 있다는 뜻                    어디에 메모 남기고 가면 다른 사람이 보고 확인하는 방식이랑 비슷 ㅋㅋ           system call은 공유 memory 영역을 설정하는데만 필요함           모든 access는 routine memory access로 처리됨                       Message Passing : 공유 변수에 의존하지 않고 process가 각각 통신함                    카톡 보내는거랑 비슷합니다요           작은 양의 data(simple data)를 교환하는데 유용함           충돌 없이 구현하기게 쉬움                           - Shard Memory      통신하는 Process간 공유되는 memory 공간이 있음   통신은 OS가 아닌 User process의 제어 아래에 있음 → User process에 따라서 통신   User process가 공유 메모리에 접근 할 때 동기화 하는 방법을 제공하는 것이 가장 큰 문제! → Producer - Consumer 문제   동기화에 대해서는 나중에 . . .   - Producer - Consumer Problem (in shard memory)           Cooperatin process의 패러다임, 생산자 프로세스는 소비자 프로세스가 소비하는 정보를 생산함       → 정보가 없는데 소비자가 소비하려하거나, 정보가 가득 찼는데 정보를 생성하려는 문제가 발생하지 않도록       공유 memory는  Buffer를 사용하여 Buffer의 item이 Producer에 의해 채워지고, Consumer에 의해 비워지는 방식 사용            동시에 접근하는 문제를 해결하기 위한 방법임!           Unbounded-Buffer            Buffer의 크기에 실질적인 제한을 두지 않아 producer는 항상 생산하도록       Consumer는 buffer가 empty라면 기다려야함           Bounded-Buffer → Circular Buffer            Buffer의 크기가 고정되어있다고 가정하여 Producer는 buffer가 가득 찼다면 기다려야함       Consumer는 마찬가지로 buffer가 empty라면 기다려야함           [Bounded-Buffer]   #define BUFFER_SIZE 10  typedef struct { \t... } item;  item buffer[BUFFER_SIZE];  int in = 0;          // point to next free position (Producer가 생성해서 넣을 위치) int out = 0;         // point to first full position (Consumer가 받을 위치)*          If in == out : Buffer is Empty → 넣을 곳과 가져올 곳이 동일하니   If ((in+1) % BUFFER_SIZE) == out : Buffer is Full → 넣을 곳 다음이 바로 가져올 곳이니 한바퀴 돌았다는 뜻            왜? in+1 == out  이면 가득찼다는 것인데 overflow 방지를 위해 순환식으로 사용하다보니까 모듈값이 out이 되어야함                이 해결 방법이 제대로 작동하긴 하지만 BUFFER_SIZE-1 개의 element만 사용할 수 있다는 단점이 있음       → Full 일 때 in과 out 이 차이가 나야 Full 과 Empty 구별가능하니까 하나 비워두기       // Producer while (true) { \t/* Produce an item */ \twhile ((**(in + 1) % BUFFER_SIZE)**  == out);    /* free buffer가 없는 동안에는 (full 상태) 아무것도 안함 */   \t/* full 이 아니면 */ \tbuffer[in] = item; \tin = **(in + 1) % BUFFER SIZE**;                 /* overflow 방지하기 위해 순환방식을 사용하고자 modular */ }  // Consumer while (true) { \twhile (in == out);                           /*  buffer 안에 아무것도 없는 동안 (empty 상태) 아무것도 안함 */  \t// remove an item from the buffer \titem = buffer[out];  \tout = **(out + 1) % BUFFER SIZE**;               /* overflow 방지하기 위해 순환방식을 사용하고자 modular */ }*   - Message Passing      Process간 서로 통신하고 행동을 동기화하는 매커니즘 → 동기화한다는 점에서 공유 메모리랑 다르죠            shard memory 는 mem 을 동기화, 얘는 행동을 동기화           동일한 주소 공간을 쓰지 않고, Process간 직접 통신하고 동기화할 수 있도록 허용   Direct / Indirect 2가지 통신이 있음            Direct는 누구한테 보내고 받는 지를 명시 → 직배송       Indirect는 mail box같은 것을 통해서 전달함 → 배대지 사용하는 느낌?           2가지 Operation (직접 통신 버전) 제공            Send(receiverID, message) → message size는 구현에 따라 고정일 수도 있고, 변수일 수도 있음                Receive(senderID, message)           *  Indirect였다면 ID 가 아니라 mailbox 위치가 파라미터로 사용                   두 Process간 통신 할 때 다음 과정이 필요            그들간 communication link 설정 → 통신망 느낌       send/receive 를 통해 message 교환                    Soket programming처럼 soket만들고 연결 link 만들고 soket 보내는 방식과 유사                           구현 문제..            link 어케 설정해?       모든 통신 process 쌍 간에 몇개의 link가 있을 수 있을까?       link의 capacity는?       message 크기는 고정이야 가변이야?       link는 단방향이야 양방향이야?           - Synchronization (in message passing)      message passing 에는 block / non-block 방식이 있음   Blocking → rendezvous (랑데뷰) 방식            Synchronize로 간주됨 (응답 올 때 까지 대기! 암거도 못해!)       Block-send : Sender가 msg 보낸 후, Reciver가 받을 때 까지 Send를 block (sender 아님!!! send method를 블락한다는거)       Block-receive : Msg를 사용할 수 있을 때 까지 Receive를 block (reveiver 아님!!! receive method를 블락한다는거)           Non-blocking            Asynchonize로 간주됨 (응답 오던 말던 다 함 ㅋ)       Nonblock-send  **:** Sender가 msg보낸 후에도 계속 send 할 수 있도록 허용       Nonblock-receive : vaild message나 null을 retrieve할 수 있도록 허용 (받는 담에 vaild일 떄만 ㄹㅇ 받아융)           non-block 방식이 더 유용함!   message next_produced;   while (true) { \t/* produce an item in next produced */ \tsend(next_produced);  // 계속 보냄 }  message next_consumed;   while (true) { \treceive(next_consumed); // -&gt; 일단 받고 ㅋㅋ \t/* consume the item in next consumed */  }*   - Buffering      Indirect 방식에서 사용 . . ? Message 수용하는..   Link에 message Queue를 연결하는 방식으로 다음 3가지 중 보통 하나는 사용            Zero capacity : 0 message 가능                 Queue의 수용 공간이 0이라 msg 보관이 안됨       그렇기에 sender는 receiver가 받을 때까지 기다려야함 (block) → rendezvous (랑데뷰) 방식                    Bounded capacity : 유한한 N 개의 message 가능                       N 길이의 Queue를 가짐       Link가 Full이라면 sender는 기다려야함 (block)                    Unbounded capacity : 무한한 message . . 가능                       Sender가 기다릴 일이 없어용 ~  !          ","categories": ["[2023]Operating System"],
        "tags": ["OS","강의필기"],
        "url": "/categories/study/2023_OS/ch3",
        "teaser": null
      }]
